<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Online Plane Shooter</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --cyan: #00ffff;
        --orange: #ff9933;
        --bg: #0a0a0f;
        --panel: rgba(15, 15, 25, 0.65);
        --glow: 0 0 15px var(--cyan), 0 0 30px rgba(0, 255, 255, 0.25);
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Orbitron", sans-serif;
        background: var(--bg);
        background-image: radial-gradient(
            circle at 20% 30%,
            rgba(0, 255, 255, 0.08) 0%,
            transparent 40%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(255, 153, 51, 0.06) 0%,
            transparent 40%
          );
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #fff;
        overflow: hidden;
      }
      #gameWrapper {
        width: 90vw;
        max-width: 840px;
        animation: fadeIn 1s ease-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      #roomOverlay {
        position: fixed;
        inset: 0;
        background: rgba(10, 10, 15, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      #roomBox {
        background: var(--panel);
        border: 1px solid var(--cyan);
        border-radius: 16px;
        padding: 40px 50px;
        text-align: center;
        box-shadow: var(--glow);
      }
      #roomBox h2 {
        margin-bottom: 20px;
        font-size: 28px;
        letter-spacing: 2px;
        text-shadow: 0 0 10px var(--cyan);
      }
      #roomInput {
        width: 220px;
        padding: 12px 16px;
        font-size: 18px;
        border-radius: 8px;
        border: 1px solid var(--cyan);
        background: rgba(0, 255, 255, 0.05);
        color: #fff;
        text-align: center;
        letter-spacing: 1px;
      }
      #roomInput::placeholder {
        color: rgba(0, 255, 255, 0.4);
      }
      #roomBtn {
        margin-top: 20px;
        padding: 12px 28px;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        background: var(--cyan);
        color: #000;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      #roomBtn:hover {
        box-shadow: 0 0 20px var(--cyan);
        transform: scale(1.05);
      }
      #loader {
        position: fixed;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        animation: fadeOut 1s 2s forwards;
      }
      @keyframes fadeOut {
        to {
          opacity: 0;
          pointer-events: none;
        }
      }
      .loaderText {
        font-size: 24px;
        margin-bottom: 12px;
        animation: pulse 1.2s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
      }
      .bar {
        width: 220px;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }
      .barFill {
        height: 100%;
        width: 0%;
        background: var(--cyan);
        animation: load 1.5s ease-out 1s forwards;
      }
      @keyframes load {
        to {
          width: 100%;
        }
      }
      #inGameHUD {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 20px;
        align-items: center;
        z-index: 10;
      }
      .hudCard {
        background: var(--panel);
        border: 1px solid var(--cyan);
        border-radius: 12px;
        padding: 10px 16px;
        box-shadow: var(--glow);
        min-width: 180px;
      }
      .hudTitle {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0.7;
        margin-bottom: 6px;
      }
      .hpBar {
        width: 100%;
        height: 10px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 5px;
        overflow: hidden;
      }
      .hpFill {
        height: 100%;
        width: 100%;
        background: linear-gradient(90deg, var(--cyan), #00ff99);
        transition: width 0.3s ease;
      }
      .cooldownRow {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }
      .cooldownCircle {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(0, 255, 255, 0.08);
        border: 1px solid rgba(0, 255, 255, 0.4);
        position: relative;
        overflow: hidden;
      }
      .cooldownCircle canvas {
        width: 100%;
        height: 100%;
      }
      #scoreTxt {
        font-size: 20px;
        letter-spacing: 2px;
        text-shadow: 0 0 10px var(--cyan);
      }
      #gameContainer {
        position: relative;
        background: var(--panel);
        border: 1px solid rgba(0, 255, 255, 0.3);
        border-radius: 16px;
        box-shadow: var(--glow);
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #controls {
        margin-top: 18px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
      }
      .controlBlock {
        text-align: center;
      }
      .keyRow {
        display: flex;
        gap: 6px;
        margin-bottom: 6px;
      }
      .key {
        padding: 10px 14px;
        border-radius: 10px;
        background: linear-gradient(
          145deg,
          rgba(0, 255, 255, 0.08),
          rgba(0, 255, 255, 0.02)
        );
        border: 1px solid rgba(0, 255, 255, 0.4);
        color: #aafaff;
        text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.2),
          inset 0 0 10px rgba(0, 255, 255, 0.15);
        transition: all 0.15s ease;
      }
      .key.pressed {
        transform: scale(0.95);
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.7),
          inset 0 0 15px rgba(0, 255, 255, 0.4);
        color: #fff;
      }
      .key.mouse {
        background: linear-gradient(
          145deg,
          rgba(255, 165, 0, 0.1),
          rgba(255, 165, 0, 0.02)
        );
        border-color: rgba(255, 165, 0, 0.4);
        color: #ffd9a0;
        text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
      }
      .label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0.8;
        margin-top: 4px;
      }
    </style>
  </head>
  <body>
    <!-- Room Code Overlay -->
    <div id="roomOverlay">
      <div id="roomBox">
        <h2>ENTER ROOM CODE</h2>
        <input
          id="roomInput"
          type="text"
          placeholder="e.g. 1234"
          maxlength="10"
        />
        <br />
        <button id="roomBtn">JOIN</button>
      </div>
    </div>

    <!-- Waiting Loader -->
    <div id="loader" style="display: none">
      <div class="loaderText">Waiting for opponent‚Ä¶</div>
      <div class="bar"><div class="barFill"></div></div>
    </div>

    <!-- Game Screen -->
    <div id="gameWrapper" style="display: none">
      <!-- New HUD -->
      <div id="inGameHUD">
        <div class="hudCard">
          <div class="hudTitle">P1 HEALTH</div>
          <div class="hpBar"><div class="hpFill" id="p1Health"></div></div>
          <div class="cooldownRow">
            <div class="cooldownCircle" id="p1Basic">
              <canvas width="36" height="36"></canvas>
            </div>
            <div class="cooldownCircle" id="p1Fast">
              <canvas width="36" height="36"></canvas>
            </div>
          </div>
        </div>
        <div id="scoreTxt">1 V 1</div>
        <div class="hudCard">
          <div class="hudTitle">P2 HEALTH</div>
          <div class="hpBar"><div class="hpFill" id="p2Health"></div></div>
          <div class="cooldownRow">
            <div class="cooldownCircle" id="p2Basic">
              <canvas width="36" height="36"></canvas>
            </div>
            <div class="cooldownCircle" id="p2Fast">
              <canvas width="36" height="36"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div id="gameContainer">
        <canvas id="gameCanvas" width="780" height="300"></canvas>
      </div>

      <div id="controls">
        <div class="controlBlock">
          <div class="keyRow"><div class="key" data-key="ArrowUp">‚¨ÜÔ∏è</div></div>
          <div class="keyRow">
            <div class="key" data-key="ArrowLeft">‚¨ÖÔ∏è</div>
            <div class="key" data-key="ArrowDown">‚¨áÔ∏è</div>
            <div class="key" data-key="ArrowRight">‚û°Ô∏è</div>
          </div>
          <div class="label">Movement</div>
        </div>
        <div class="controlBlock">
          <div class="keyRow">
            <div class="key mouse" data-mouse="left">üñ±Ô∏è Left</div>
          </div>
          <div class="label">Fire</div>
        </div>
        <div class="controlBlock">
          <div class="keyRow">
            <div class="key mouse" data-mouse="right">üñ±Ô∏è Right</div>
          </div>
          <div class="label">Fast Fire</div>
        </div>
      </div>
    </div>

    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script>
      const socket = io("https://onev1-h4qx.onrender.com");
      let playerIndex, gameState, roomId;
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const keys = {},
        mouse = { left: false, right: false };

      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        const k = document.querySelector(`[data-key="${e.key}"]`);
        if (k) k.classList.add("pressed");
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        const k = document.querySelector(`[data-key="${e.key}"]`);
        if (k) k.classList.remove("pressed");
      });
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) mouse.left = true;
        if (e.button === 2) mouse.right = true;
        const k = document.querySelector(
          `[data-mouse="${e.button === 0 ? "left" : "right"}"]`
        );
        if (k) k.classList.add("pressed");
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) mouse.left = false;
        if (e.button === 2) mouse.right = false;
        const k = document.querySelector(
          `[data-mouse="${e.button === 0 ? "left" : "right"}"]`
        );
        if (k) k.classList.remove("pressed");
      });
      window.addEventListener("contextmenu", (e) => e.preventDefault());

      // room overlay
      const roomOverlay = document.getElementById("roomOverlay");
      const roomInput = document.getElementById("roomInput");
      const roomBtn = document.getElementById("roomBtn");
      roomBtn.onclick = () => {
        roomId = roomInput.value.trim();
        if (!roomId) {
          roomInput.focus();
          return;
        }
        socket.emit("joinRoom", roomId);
        roomOverlay.style.display = "none";
        document.getElementById("loader").style.display = "flex";
      };
      roomInput.addEventListener("keyup", (e) => {
        if (e.key === "Enter") roomBtn.click();
      });
      roomInput.focus();

      socket.on("init", (data) => {
        playerIndex = data.playerIndex;
        gameState = data.state;
      });
      socket.on("startGame", (state) => {
        gameState = state;
        document.getElementById("loader").style.display = "none";
        document.getElementById("gameWrapper").style.display = "flex";
        animate();
      });
      socket.on("roomFull", () => {
        alert("Room is full!");
        location.reload();
      });
      socket.on("playerLeft", () => {
        alert("Other player left!");
        location.reload();
      });
      socket.on("gameOver", (data) => {
        alert(data.winner === playerIndex ? "You win!" : "You lose!");
        location.reload();
      });

      // ---- networking ----
      let lastSnap = null,
        newSnap = null,
        snapTime = 0;
      socket.on("update", (pack) => {
        lastSnap = newSnap || pack.d;
        newSnap = pack.d;
        snapTime = pack.t;
      });

      const PLAYER_SPEED = 7;
      function sendInput() {
        if (playerIndex === undefined || !gameState) {
          requestAnimationFrame(sendInput);
          return;
        }
        const input = {
          up: keys["ArrowUp"] || false,
          down: keys["ArrowDown"] || false,
          left: keys["ArrowLeft"] || false,
          right: keys["ArrowRight"] || false,
          fire: mouse.left || false,
          fastFire: mouse.right || false,
        };
        const me = gameState.players[playerIndex];
        if (me) {
          if (input.up) me.y -= PLAYER_SPEED;
          if (input.down) me.y += PLAYER_SPEED;
          if (input.left) me.x -= PLAYER_SPEED;
          if (input.right) me.x += PLAYER_SPEED;
          me.x = Math.max(0, Math.min(780 - 60, me.x));
          me.y = Math.max(0, Math.min(300 - 60, me.y));
        }
        socket.emit("input", { roomId, input });
        requestAnimationFrame(sendInput);
      }
      sendInput();

      // ---- render helpers ----
      function drawCooldown(ctx, ratio, color) {
        const s = 36;
        ctx.clearRect(0, 0, s, s);
        if (ratio <= 0) return;
        const ang = ratio * 2 * Math.PI;
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.moveTo(s / 2, s / 2);
        ctx.arc(s / 2, s / 2, s / 2, -Math.PI / 2, -Math.PI / 2 + ang);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      function drawPlane(p) {
        const topH = p.height * 0.2;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 12;
        ctx.fillStyle = "rgba(255,255,255,.1)";
        ctx.fillRect(p.x, p.y, p.width, topH);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y + topH, p.width, p.height - topH);
        ctx.fillStyle = "#0f0";
        const hpRatio = Math.max(0, p.hp / 50);
        ctx.fillRect(p.x, p.y, p.width * hpRatio, topH);
        ctx.shadowBlur = 0;
      }
      function drawMissiles() {
        ctx.shadowColor = "yellow";
        ctx.shadowBlur = 15;
        gameState.missiles.forEach((m) => {
          ctx.fillStyle = "yellow";
          ctx.fillRect(m.x, m.y, m.w, m.h);
        });
        ctx.shadowBlur = 0;
      }
      function updateHealth() {
        if (!gameState) return;
        document.getElementById("p1Health").style.width =
          gameState.players[0].hp * 2 + "%";
        document.getElementById("p2Health").style.width =
          gameState.players[1].hp * 2 + "%";
      }

      // ---- main loop ----
      function animate() {
        if (!gameState || !lastSnap || !newSnap) {
          requestAnimationFrame(animate);
          return;
        }
        const now = Date.now(),
          dt = Math.min(1, (now - snapTime) / 50);
        function l(a, b, t) {
          return a + (b - a) * t;
        }
        const [p0x, p0y, p1x, p1y] = [
          l(
            lastSnap.p0x ?? gameState.players[0].x,
            newSnap.p0x ?? gameState.players[0].x,
            dt
          ),
          l(
            lastSnap.p0y ?? gameState.players[0].y,
            newSnap.p0y ?? gameState.players[0].y,
            dt
          ),
          l(
            lastSnap.p1x ?? gameState.players[1].x,
            newSnap.p1x ?? gameState.players[1].x,
            dt
          ),
          l(
            lastSnap.p1y ?? gameState.players[1].y,
            newSnap.p1y ?? gameState.players[1].y,
            dt
          ),
        ];
        gameState.players[0].x = p0x;
        gameState.players[0].y = p0y;
        gameState.players[1].x = p1x;
        gameState.players[1].y = p1y;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        gameState.players.forEach(drawPlane);
        drawMissiles();
        updateHealth();
        // cooldown rings
        drawCooldown(
          cooldownCtx.p1b,
          gameState.players[0].basicCD / 0.5,
          "#0ff"
        );
        drawCooldown(
          cooldownCtx.p1f,
          gameState.players[0].fastCD / 6,
          "#ffb84d"
        );
        drawCooldown(
          cooldownCtx.p2b,
          gameState.players[1].basicCD / 0.5,
          "#0ff"
        );
        drawCooldown(
          cooldownCtx.p2f,
          gameState.players[1].fastCD / 6,
          "#ffb84d"
        );
        requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>
