<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Online Plane Shooter</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --cyan: #00ffff;
        --orange: #ff9933;
        --bg: #050510;
        --panel: rgba(10, 15, 30, 0.85);
        --glow: 0 0 20px var(--cyan), 0 0 40px rgba(0, 255, 255, 0.3);
        --glow-orange: 0 0 20px var(--orange), 0 0 40px rgba(255, 153, 51, 0.3);
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Orbitron", sans-serif;
        background: var(--bg);
        background-image: radial-gradient(
            circle at 20% 30%,
            rgba(0, 255, 255, 0.12) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 70%,
            rgba(255, 153, 51, 0.08) 0%,
            transparent 50%
          ),
          repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            rgba(0, 255, 255, 0.03) 2px,
            rgba(0, 255, 255, 0.03) 4px
          );
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #fff;
        overflow: hidden;
      }
      #gameWrapper {
        width: 90vw;
        max-width: 900px;
        animation: fadeIn 1s ease-out;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      #roomOverlay {
        position: fixed;
        inset: 0;
        background: rgba(10, 10, 15, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      #roomBox {
        background: var(--panel);
        border: 1px solid var(--cyan);
        border-radius: 16px;
        padding: 40px 50px;
        text-align: center;
        box-shadow: var(--glow);
      }
      #roomBox h2 {
        margin-bottom: 20px;
        font-size: 28px;
        letter-spacing: 2px;
        text-shadow: 0 0 10px var(--cyan);
      }
      #roomInput {
        width: 220px;
        padding: 12px 16px;
        font-size: 18px;
        border-radius: 8px;
        border: 1px solid var(--cyan);
        background: rgba(0, 255, 255, 0.05);
        color: #fff;
        text-align: center;
        letter-spacing: 1px;
      }
      #roomInput::placeholder {
        color: rgba(0, 255, 255, 0.4);
      }
      #roomBtn {
        margin-top: 20px;
        padding: 12px 28px;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        background: var(--cyan);
        color: #000;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      #roomBtn:hover {
        box-shadow: 0 0 20px var(--cyan);
        transform: scale(1.05);
      }
      #loader {
        position: fixed;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        animation: fadeOut 1s 2s forwards;
      }
      @keyframes fadeOut {
        to {
          opacity: 0;
          pointer-events: none;
        }
      }
      .loaderText {
        font-size: 24px;
        margin-bottom: 12px;
        animation: pulse 1.2s infinite;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
      }
      .bar {
        width: 220px;
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }
      .barFill {
        height: 100%;
        width: 0%;
        background: var(--cyan);
        animation: load 1.5s ease-out 1s forwards;
      }
      @keyframes load {
        to {
          width: 100%;
        }
      }
      #inGameHUD {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: center;
      }
      .hudCard {
        background: var(--panel);
        border: 2px solid var(--cyan);
        border-radius: 12px;
        padding: 12px 18px;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        min-width: 180px;
        backdrop-filter: blur(10px);
      }
      .hudCard:last-child {
        border-color: var(--orange);
        box-shadow: 0 0 15px rgba(255, 153, 51, 0.2);
      }
      .hudTitle {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 2px;
        opacity: 0.9;
        margin-bottom: 8px;
        font-weight: 700;
        text-shadow: 0 0 10px currentColor;
      }
      .hpBar {
        width: 100%;
        height: 14px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 7px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .hpFill {
        height: 100%;
        width: 100%;
        background: linear-gradient(90deg, var(--cyan), #00ff99);
        transition: width 0.3s ease;
        box-shadow: 0 0 15px var(--cyan);
      }
      .hudCard:last-child .hpFill {
        background: linear-gradient(90deg, var(--orange), #ffcc00);
        box-shadow: 0 0 15px var(--orange);
      }
      .cooldownRow {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        justify-content: center;
      }
      .cooldownCircle {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid rgba(0, 255, 255, 0.4);
        position: relative;
        overflow: hidden;
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.2);
      }
      .cooldownCircle canvas {
        width: 100%;
        height: 100%;
      }
      .hudCard:last-child .cooldownCircle {
        border-color: rgba(255, 153, 51, 0.4);
        box-shadow: 0 0 8px rgba(255, 153, 51, 0.2);
      }
      #scoreTxt {
        font-size: 28px;
        font-weight: 700;
        letter-spacing: 3px;
        color: #fff;
        text-shadow: 0 0 15px var(--cyan);
      }
      #gameContainer {
        position: relative;
        background: rgba(10, 15, 30, 0.8);
        border: 2px solid var(--cyan);
        border-radius: 16px;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #controls {
        display: flex;
        justify-content: space-around;
        align-items: center;
        gap: 40px;
        padding: 20px;
        background: var(--panel);
        border: 2px solid rgba(0, 255, 255, 0.2);
        border-radius: 12px;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
      }
      .controlBlock {
        text-align: center;
      }
      .keyRow {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
        justify-content: center;
      }
      .key {
        padding: 10px 14px;
        border-radius: 8px;
        background: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        color: var(--cyan);
        font-weight: 600;
        text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        transition: all 0.15s ease;
        cursor: pointer;
        min-width: 44px;
        user-select: none;
      }
      .key:hover {
        background: rgba(0, 255, 255, 0.15);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      }
      .key.pressed {
        transform: scale(0.95);
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        background: rgba(0, 255, 255, 0.25);
        color: #fff;
      }
      .key.mouse {
        background: rgba(255, 153, 51, 0.1);
        border-color: rgba(255, 153, 51, 0.4);
        color: var(--orange);
        text-shadow: 0 0 8px rgba(255, 153, 51, 0.6);
        box-shadow: 0 0 10px rgba(255, 153, 51, 0.2);
      }
      .key.mouse:hover {
        background: rgba(255, 153, 51, 0.15);
        box-shadow: 0 0 15px rgba(255, 153, 51, 0.3);
      }
      .key.mouse.pressed {
        box-shadow: 0 0 20px rgba(255, 153, 51, 0.5);
        background: rgba(255, 153, 51, 0.25);
      }
      .label {
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 2px;
        opacity: 0.9;
        margin-top: 8px;
        font-weight: 600;
        text-shadow: 0 0 10px currentColor;
      }
    </style>
  </head>
  <body>
    <!-- Room Code Overlay -->
    <div id="roomOverlay">
      <div id="roomBox">
        <h2>ENTER ROOM CODE</h2>
        <input
          id="roomInput"
          type="text"
          placeholder="e.g. 1234"
          maxlength="10"
        />
        <br />
        <button id="roomBtn">JOIN</button>
      </div>
    </div>

    <!-- Waiting Loader -->
    <div id="loader" style="display: none">
      <div class="loaderText">Waiting for opponent‚Ä¶</div>
      <div class="bar"><div class="barFill"></div></div>
    </div>

    <!-- Game Screen -->
    <div id="gameWrapper" style="display: none">
      <!-- New HUD -->
      <div id="inGameHUD">
        <div class="hudCard">
          <div class="hudTitle">P1 HEALTH</div>
          <div class="hpBar"><div class="hpFill" id="p1Health"></div></div>
          <div class="cooldownRow">
            <div class="cooldownCircle" id="p1Basic">
              <canvas width="36" height="36"></canvas>
            </div>
            <div class="cooldownCircle" id="p1Fast">
              <canvas width="36" height="36"></canvas>
            </div>
          </div>
        </div>
        <div id="scoreTxt">1 V 1</div>
        <div class="hudCard">
          <div class="hudTitle">P2 HEALTH</div>
          <div class="hpBar"><div class="hpFill" id="p2Health"></div></div>
          <div class="cooldownRow">
            <div class="cooldownCircle" id="p2Basic">
              <canvas width="36" height="36"></canvas>
            </div>
            <div class="cooldownCircle" id="p2Fast">
              <canvas width="36" height="36"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div id="gameContainer">
        <canvas id="gameCanvas" width="780" height="300"></canvas>
      </div>

      <div id="controls">
        <div class="controlBlock">
          <div class="keyRow"><div class="key" data-key="ArrowUp">‚¨ÜÔ∏è</div></div>
          <div class="keyRow">
            <div class="key" data-key="ArrowLeft">‚¨ÖÔ∏è</div>
            <div class="key" data-key="ArrowDown">‚¨áÔ∏è</div>
            <div class="key" data-key="ArrowRight">‚û°Ô∏è</div>
          </div>
          <div class="label">Movement</div>
        </div>
        <div class="controlBlock">
          <div class="keyRow">
            <div class="key mouse" data-mouse="left">üñ±Ô∏è Left</div>
          </div>
          <div class="label">Fire</div>
        </div>
        <div class="controlBlock">
          <div class="keyRow">
            <div class="key mouse" data-mouse="right">üñ±Ô∏è Right</div>
          </div>
          <div class="label">Fast Fire</div>
        </div>
      </div>
    </div>

    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script>
      const socket = io("https://onev1-h4qx.onrender.com");
      let playerIndex, gameState, roomId;
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const keys = {},
        mouse = { left: false, right: false };

      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        const k = document.querySelector(`[data-key="${e.key}"]`);
        if (k) k.classList.add("pressed");
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        const k = document.querySelector(`[data-key="${e.key}"]`);
        if (k) k.classList.remove("pressed");
      });
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) mouse.left = true;
        if (e.button === 2) mouse.right = true;
        const k = document.querySelector(
          `[data-mouse="${e.button === 0 ? "left" : "right"}"]`
        );
        if (k) k.classList.add("pressed");
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) mouse.left = false;
        if (e.button === 2) mouse.right = false;
        const k = document.querySelector(
          `[data-mouse="${e.button === 0 ? "left" : "right"}"]`
        );
        if (k) k.classList.remove("pressed");
      });
      window.addEventListener("contextmenu", (e) => e.preventDefault());

      // room overlay
      const roomOverlay = document.getElementById("roomOverlay");
      const roomInput = document.getElementById("roomInput");
      const roomBtn = document.getElementById("roomBtn");
      roomBtn.onclick = () => {
        roomId = roomInput.value.trim();
        if (!roomId) {
          roomInput.focus();
          return;
        }
        socket.emit("joinRoom", roomId);
        roomOverlay.style.display = "none";
        document.getElementById("loader").style.display = "flex";
      };
      roomInput.addEventListener("keyup", (e) => {
        if (e.key === "Enter") roomBtn.click();
      });
      roomInput.focus();

      socket.on("init", (data) => {
        playerIndex = data.playerIndex;
        gameState = data.state;
      });
      socket.on("startGame", (state) => {
        gameState = state;
        document.getElementById("loader").style.display = "none";
        document.getElementById("gameWrapper").style.display = "flex";
        animate();
      });
      socket.on("roomFull", () => {
        alert("Room is full!");
        location.reload();
      });
      socket.on("playerLeft", () => {
        alert("Other player left!");
        location.reload();
      });
      socket.on("gameOver", (data) => {
        alert(data.winner === playerIndex ? "You win!" : "You lose!");
        location.reload();
      });

      // ---- networking ----
      let lastSnap = null,
        newSnap = null,
        snapTime = 0;
      socket.on("update", (pack) => {
        lastSnap = newSnap || pack.d;
        newSnap = pack.d;
        snapTime = pack.t;
      });

      const PLAYER_SPEED = 7;
      function sendInput() {
        if (playerIndex === undefined || !gameState) {
          requestAnimationFrame(sendInput);
          return;
        }
        const input = {
          up: keys["ArrowUp"] || false,
          down: keys["ArrowDown"] || false,
          left: keys["ArrowLeft"] || false,
          right: keys["ArrowRight"] || false,
          fire: mouse.left || false,
          fastFire: mouse.right || false,
        };
        const me = gameState.players[playerIndex];
        if (me) {
          if (input.up) me.y -= PLAYER_SPEED;
          if (input.down) me.y += PLAYER_SPEED;
          if (input.left) me.x -= PLAYER_SPEED;
          if (input.right) me.x += PLAYER_SPEED;
          me.x = Math.max(0, Math.min(780 - 60, me.x));
          me.y = Math.max(0, Math.min(300 - 60, me.y));
        }
        socket.emit("input", { roomId, input });
        requestAnimationFrame(sendInput);
      }
      sendInput();

      // ---- render helpers ----
      const cooldownCtx = {
        p1b: document
          .getElementById("p1Basic")
          .querySelector("canvas")
          .getContext("2d"),
        p1f: document
          .getElementById("p1Fast")
          .querySelector("canvas")
          .getContext("2d"),
        p2b: document
          .getElementById("p2Basic")
          .querySelector("canvas")
          .getContext("2d"),
        p2f: document
          .getElementById("p2Fast")
          .querySelector("canvas")
          .getContext("2d"),
      };

      function drawCooldown(ctx, ratio, color) {
        const s = 36;
        ctx.clearRect(0, 0, s, s);
        if (ratio <= 0) return;
        const ang = ratio * 2 * Math.PI;
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(s / 2, s / 2);
        ctx.arc(s / 2, s / 2, s / 2, -Math.PI / 2, -Math.PI / 2 + ang);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      function drawPlane(p) {
        if (!p || p.x === undefined || p.y === undefined) return;
        
        // Reset any previous styles
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        
        // Main body
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.fillRect(p.x, p.y, p.width, p.height);

        // Cockpit highlight
        ctx.shadowBlur = 0;
        ctx.fillStyle = "rgba(255,255,255,0.15)";
        ctx.fillRect(p.x, p.y, p.width, p.height * 0.2);

        // Health bar background
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(p.x, p.y - 6, p.width, 4);

        // Health bar fill
        const hpRatio = Math.max(0, p.hp / 50);
        if (hpRatio > 0.5) {
          ctx.fillStyle = "#00ff88";
        } else if (hpRatio > 0.2) {
          ctx.fillStyle = "#ffcc00";
        } else {
          ctx.fillStyle = "#ff4444";
        }
        ctx.fillRect(p.x, p.y - 6, p.width * hpRatio, 4);

        // Reset shadow
        ctx.shadowBlur = 0;
      }
      function drawMissiles() {
        if (!gameState.missiles || gameState.missiles.length === 0) return;
        
        // Reset any previous styles
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
        
        gameState.missiles.forEach((m) => {
          if (!m || m.x === undefined) return;
          
          ctx.shadowColor = "#ffdd00";
          ctx.shadowBlur = 20;

          // Missile body
          ctx.fillStyle = "#ffdd00";
          ctx.fillRect(m.x, m.y, m.w, m.h);

          // Bright core
          ctx.shadowBlur = 0;
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.fillRect(m.x + m.w * 0.3, m.y + m.h * 0.3, m.w * 0.4, m.h * 0.4);
        });
        
        // Reset shadow
        ctx.shadowBlur = 0;
      }
      function updateHealth() {
        if (!gameState) return;
        document.getElementById("p1Health").style.width =
          gameState.players[0].hp * 2 + "%";
        document.getElementById("p2Health").style.width =
          gameState.players[1].hp * 2 + "%";
      }

      // ---- main loop ----
      function animate() {
        if (!gameState) {
          requestAnimationFrame(animate);
          return;
        }

        // Apply server updates if available
        if (newSnap) {
          if (newSnap.p0x !== undefined) gameState.players[0].x = newSnap.p0x;
          if (newSnap.p0y !== undefined) gameState.players[0].y = newSnap.p0y;
          if (newSnap.p1x !== undefined) gameState.players[1].x = newSnap.p1x;
          if (newSnap.p1y !== undefined) gameState.players[1].y = newSnap.p1y;
          if (newSnap.m !== undefined) gameState.missiles = newSnap.m;
          if (newSnap.p0b !== undefined) gameState.players[0].basicCD = newSnap.p0b;
          if (newSnap.p0f !== undefined) gameState.players[0].fastCD = newSnap.p0f;
          if (newSnap.p1b !== undefined) gameState.players[1].basicCD = newSnap.p1b;
          if (newSnap.p1f !== undefined) gameState.players[1].fastCD = newSnap.p1f;
          if (newSnap.p0h !== undefined) gameState.players[0].hp = newSnap.p0h;
          if (newSnap.p1h !== undefined) gameState.players[1].hp = newSnap.p1h;
        }

        // Clear canvas completely
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw dark background
        ctx.fillStyle = "rgba(10, 15, 30, 0.95)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw everything
        if (gameState.players && gameState.players.length >= 2) {
          gameState.players.forEach(drawPlane);
        }
        drawMissiles();
        updateHealth();
        
        // cooldown rings
        if (gameState.players[0]) {
          drawCooldown(
            cooldownCtx.p1b,
            gameState.players[0].basicCD / 0.5,
            "#0ff"
          );
          drawCooldown(
            cooldownCtx.p1f,
            gameState.players[0].fastCD / 6,
            "#ffb84d"
          );
        }
        if (gameState.players[1]) {
          drawCooldown(
            cooldownCtx.p2b,
            gameState.players[1].basicCD / 0.5,
            "#0ff"
          );
          drawCooldown(
            cooldownCtx.p2f,
            gameState.players[1].fastCD / 6,
            "#ffb84d"
          );
        }
        
        requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>
